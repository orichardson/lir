#!/usr/bin/env python3
"""
Visualize PDGs generated by the experimental setup.
"""

import sys
from pathlib import Path
import random
import numpy as np
import torch
import matplotlib.pyplot as plt
import seaborn as sns
import networkx as nx
from typing import List, Dict, Tuple, Any
import json

# Add project paths
sys.path.insert(0, str(Path(__file__).resolve().parents[0]))

from pdg.pdg import PDG
from pdg.rv import Variable as Var
from pdg.dist import CPT
from experimental_setup import PDGGenerator, PDGSpec


def visualize_pdg_structure(pdg: PDG, spec: PDGSpec, ax=None, title_suffix=""):
    """Visualize a single PDG structure."""
    if ax is None:
        fig, ax = plt.subplots(1, 1, figsize=(8, 6))
    
    # Create NetworkX graph for visualization
    G = nx.DiGraph()
    
    # Add nodes
    for var_name, var in pdg.vars.items():
        if var_name != "1":  # Skip unit variable
            G.add_node(var_name, size=len(var))
    
    # Add edges with labels
    edge_labels = {}
    for L, X, Y, α, β, P in pdg.edges("l,X,Y,α,β,P"):
        if X.name != "1" and Y.name != "1":  # Skip unit variable edges
            G.add_edge(X.name, Y.name, label=L, alpha=α, beta=β)
            edge_labels[(X.name, Y.name)] = f"{L}\nα={α:.1f}, β={β:.1f}"
    
    # Layout
    pos = nx.spring_layout(G, seed=42, k=2, iterations=50)
    
    # Draw nodes
    node_sizes = [G.nodes[node].get('size', 2) * 300 for node in G.nodes()]
    nx.draw_networkx_nodes(G, pos, node_color='lightblue', 
                          node_size=node_sizes, alpha=0.8, ax=ax)
    
    # Draw edges
    nx.draw_networkx_edges(G, pos, edge_color='gray', 
                          arrows=True, arrowsize=20, ax=ax)
    
    # Draw labels
    nx.draw_networkx_labels(G, pos, font_size=12, font_weight='bold', ax=ax)
    
    # Draw edge labels (only for small graphs to avoid clutter)
    if len(edge_labels) <= 8:
        nx.draw_networkx_edge_labels(G, pos, edge_labels, font_size=8, ax=ax)
    
    # Title
    title = f"{spec.name.upper()}{title_suffix}\n"
    title += f"Variables: {spec.num_vars}, Edges: {len(G.edges())}\n"
    title += f"Description: {spec.description}"
    ax.set_title(title, fontsize=10, pad=20)
    ax.axis('off')
    
    return G


def visualize_pdg_details(pdg: PDG, spec: PDGSpec, ax=None):
    """Visualize detailed information about a PDG."""
    if ax is None:
        fig, ax = plt.subplots(1, 1, figsize=(10, 6))
    
    # Collect edge information
    edges_info = []
    for L, X, Y, α, β, P in pdg.edges("l,X,Y,α,β,P"):
        if X.name != "1" and Y.name != "1":
            edges_info.append({
                'edge': f"{X.name}→{Y.name}",
                'label': L,
                'alpha': α,
                'beta': β,
                'src_cardinality': len(X),
                'tgt_cardinality': len(Y)
            })
    
    if not edges_info:
        ax.text(0.5, 0.5, "No edges to display", ha='center', va='center', 
                transform=ax.transAxes, fontsize=14)
        ax.set_title(f"{spec.name} - Edge Details", fontsize=12)
        return
    
    # Create a table-like visualization
    y_positions = np.linspace(0.9, 0.1, len(edges_info))
    
    # Headers
    ax.text(0.1, 0.95, "Edge", fontweight='bold', fontsize=12, transform=ax.transAxes)
    ax.text(0.3, 0.95, "Label", fontweight='bold', fontsize=12, transform=ax.transAxes)
    ax.text(0.5, 0.95, "α", fontweight='bold', fontsize=12, transform=ax.transAxes)
    ax.text(0.6, 0.95, "β", fontweight='bold', fontsize=12, transform=ax.transAxes)
    ax.text(0.7, 0.95, "Src Size", fontweight='bold', fontsize=12, transform=ax.transAxes)
    ax.text(0.85, 0.95, "Tgt Size", fontweight='bold', fontsize=12, transform=ax.transAxes)
    
    # Data rows
    for i, edge_info in enumerate(edges_info):
        y = y_positions[i]
        ax.text(0.1, y, edge_info['edge'], fontsize=10, transform=ax.transAxes)
        ax.text(0.3, y, edge_info['label'], fontsize=10, transform=ax.transAxes)
        ax.text(0.5, y, f"{edge_info['alpha']:.1f}", fontsize=10, transform=ax.transAxes)
        ax.text(0.6, y, f"{edge_info['beta']:.1f}", fontsize=10, transform=ax.transAxes)
        ax.text(0.7, y, f"{edge_info['src_cardinality']}", fontsize=10, transform=ax.transAxes)
        ax.text(0.85, y, f"{edge_info['tgt_cardinality']}", fontsize=10, transform=ax.transAxes)
    
    ax.set_xlim(0, 1)
    ax.set_ylim(0, 1)
    ax.set_title(f"{spec.name} - Edge Details", fontsize=12)
    ax.axis('off')


def create_pdg_grid_visualization():
    """Create a comprehensive grid visualization of all PDGs."""
    print("=== Creating PDG Visualizations ===")
    
    # Create PDG generator
    generator = PDGGenerator(seed=42)
    
    # Create PDG specifications
    specs = [
        PDGSpec("small_chain", 3, 2, (2, 2), 2, 100, "Small chain structure"),
        PDGSpec("small_star", 4, 3, (2, 3), 2, 101, "Small star structure"),
        PDGSpec("medium_chain", 5, 4, (2, 3), 2, 102, "Medium chain structure"),
        PDGSpec("medium_tree", 6, 5, (2, 3), 2, 103, "Medium tree structure"),
        PDGSpec("large_chain", 7, 6, (2, 3), 2, 104, "Large chain structure"),
        PDGSpec("large_complex", 8, 7, (2, 3), 2, 105, "Large complex structure"),
    ]
    
    # Generate PDGs
    pdgs = []
    for spec in specs:
        print(f"Generating {spec.name}...")
        pdg = generator.generate_pdg(spec)
        pdgs.append(pdg)
    
    # Create comprehensive visualization
    fig = plt.figure(figsize=(20, 16))
    fig.suptitle('LIR Experimental PDGs - Structure and Details', fontsize=16, fontweight='bold')
    
    # Create subplots
    for i, (pdg, spec) in enumerate(zip(pdgs, specs)):
        # Structure visualization (left column)
        ax1 = plt.subplot(4, 6, i*2 + 1)
        G = visualize_pdg_structure(pdg, spec, ax1)
        
        # Details visualization (right column)
        ax2 = plt.subplot(4, 6, i*2 + 2)
        visualize_pdg_details(pdg, spec, ax2)
    
    plt.tight_layout()
    plt.savefig('pdg_visualizations.png', dpi=300, bbox_inches='tight')
    plt.show()
    
    return pdgs, specs


def create_attention_strategy_visualization():
    """Visualize how attention strategies affect edge weights."""
    print("\n=== Creating Attention Strategy Visualizations ===")
    
    # Create a sample PDG
    generator = PDGGenerator(seed=42)
    spec = PDGSpec("attention_demo", 5, 4, (2, 2), 2, 200, "Demo PDG for attention strategies")
    pdg = generator.generate_pdg(spec)
    
    # Import attention strategies
    from experimental_setup import AttentionStrategy
    
    strategies = {
        "Global": AttentionStrategy.global_strategy,
        "Local": AttentionStrategy.local_strategy,
        "Node-based": AttentionStrategy.node_based_strategy,
        "Exponential": AttentionStrategy.exponential_strategy
    }
    
    # Create visualization
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))
    fig.suptitle('Attention Strategy Effects on Edge Weights', fontsize=16, fontweight='bold')
    
    for i, (strategy_name, strategy_func) in enumerate(strategies.items()):
        ax = axes[i//2, i%2]
        
        # Get attention weights
        attn_alpha, attn_beta, control = strategy_func(pdg, 0)
        
        # Create NetworkX graph
        G = nx.DiGraph()
        
        # Add nodes
        for var_name, var in pdg.vars.items():
            if var_name != "1":
                G.add_node(var_name)
        
        # Add edges with beta weights
        edge_weights = []
        edge_labels = {}
        for L, X, Y, α, β, P in pdg.edges("l,X,Y,α,β,P"):
            if X.name != "1" and Y.name != "1":
                beta_weight = attn_beta.get(L, 0.0)
                G.add_edge(X.name, Y.name, weight=beta_weight)
                edge_weights.append(beta_weight)
                edge_labels[(X.name, Y.name)] = f"β={beta_weight:.2f}"
        
        # Layout
        pos = nx.spring_layout(G, seed=42)
        
        # Draw nodes
        nx.draw_networkx_nodes(G, pos, node_color='lightblue', 
                              node_size=800, alpha=0.8, ax=ax)
        
        # Draw edges with thickness based on beta weights
        if edge_weights and max(edge_weights) > 0:
            max_weight = max(edge_weights)
            edge_widths = [w/max_weight * 5 + 1 for w in edge_weights]
        else:
            edge_widths = [2] * len(G.edges())
        
        nx.draw_networkx_edges(G, pos, width=edge_widths, 
                              edge_color='gray', arrows=True, arrowsize=20, ax=ax)
        
        # Draw labels
        nx.draw_networkx_labels(G, pos, font_size=12, font_weight='bold', ax=ax)
        nx.draw_networkx_edge_labels(G, pos, edge_labels, font_size=8, ax=ax)
        
        # Title
        ax.set_title(f"{strategy_name} Strategy\nβ weights: {list(attn_beta.values())}", 
                    fontsize=12, pad=20)
        ax.axis('off')
    
    plt.tight_layout()
    plt.savefig('attention_strategy_visualizations.png', dpi=300, bbox_inches='tight')
    plt.show()


def analyze_pdg_properties(pdgs: List[PDG], specs: List[PDGSpec]):
    """Analyze and display properties of the generated PDGs."""
    print("\n=== PDG Properties Analysis ===")
    
    properties = []
    for pdg, spec in zip(pdgs, specs):
        # Count edges
        edge_count = len([e for e in pdg.edges("l,X,Y,α,β,P") 
                         if e[1].name != "1" and e[2].name != "1"])
        
        # Count variables
        var_count = len([v for v in pdg.vars.keys() if v != "1"])
        
        # Calculate average domain size
        domain_sizes = [len(v) for v in pdg.vars.values() if v.name != "1"]
        avg_domain_size = np.mean(domain_sizes) if domain_sizes else 0
        
        # Calculate graph density
        max_possible_edges = var_count * (var_count - 1)
        density = edge_count / max_possible_edges if max_possible_edges > 0 else 0
        
        properties.append({
            'name': spec.name,
            'variables': var_count,
            'edges': edge_count,
            'avg_domain_size': avg_domain_size,
            'density': density,
            'description': spec.description
        })
    
    # Create properties visualization
    fig, axes = plt.subplots(2, 2, figsize=(15, 10))
    fig.suptitle('PDG Properties Analysis', fontsize=16, fontweight='bold')
    
    # Extract data
    names = [p['name'] for p in properties]
    variables = [p['variables'] for p in properties]
    edges = [p['edges'] for p in properties]
    densities = [p['density'] for p in properties]
    avg_domains = [p['avg_domain_size'] for p in properties]
    
    # Plot 1: Variables vs Edges
    ax1 = axes[0, 0]
    ax1.scatter(variables, edges, s=100, alpha=0.7)
    for i, name in enumerate(names):
        ax1.annotate(name, (variables[i], edges[i]), xytext=(5, 5), 
                    textcoords='offset points', fontsize=8)
    ax1.set_xlabel('Number of Variables')
    ax1.set_ylabel('Number of Edges')
    ax1.set_title('Variables vs Edges')
    ax1.grid(True, alpha=0.3)
    
    # Plot 2: Graph Density
    ax2 = axes[0, 1]
    bars = ax2.bar(names, densities, color='lightcoral')
    ax2.set_ylabel('Graph Density')
    ax2.set_title('Graph Density by PDG')
    ax2.tick_params(axis='x', rotation=45)
    
    # Plot 3: Average Domain Size
    ax3 = axes[1, 0]
    bars = ax3.bar(names, avg_domains, color='lightgreen')
    ax3.set_ylabel('Average Domain Size')
    ax3.set_title('Average Domain Size by PDG')
    ax3.tick_params(axis='x', rotation=45)
    
    # Plot 4: Edge-to-Variable Ratio
    ax4 = axes[1, 1]
    ratios = [e/v if v > 0 else 0 for e, v in zip(edges, variables)]
    bars = ax4.bar(names, ratios, color='lightblue')
    ax4.set_ylabel('Edge-to-Variable Ratio')
    ax4.set_title('Edge-to-Variable Ratio by PDG')
    ax4.tick_params(axis='x', rotation=45)
    
    plt.tight_layout()
    plt.savefig('pdg_properties_analysis.png', dpi=300, bbox_inches='tight')
    plt.show()
    
    # Print summary table
    print("\nPDG Properties Summary:")
    print("-" * 80)
    print(f"{'Name':<15} {'Vars':<5} {'Edges':<6} {'Density':<8} {'Avg Domain':<10} {'Description'}")
    print("-" * 80)
    for p in properties:
        print(f"{p['name']:<15} {p['variables']:<5} {p['edges']:<6} "
              f"{p['density']:<8.3f} {p['avg_domain_size']:<10.1f} {p['description']}")
    
    return properties


def main():
    """Main function to create all PDG visualizations."""
    print("=== PDG Visualization Suite ===")
    
    # Create PDG grid visualization
    pdgs, specs = create_pdg_grid_visualization()
    
    # Create attention strategy visualization
    create_attention_strategy_visualization()
    
    # Analyze PDG properties
    properties = analyze_pdg_properties(pdgs, specs)
    
    print("\n=== Visualization Complete ===")
    print("Generated files:")
    print("  - pdg_visualizations.png (PDG structures and details)")
    print("  - attention_strategy_visualizations.png (attention strategy effects)")
    print("  - pdg_properties_analysis.png (PDG properties analysis)")
    
    return pdgs, specs, properties


if __name__ == "__main__":
    pdgs, specs, properties = main()
